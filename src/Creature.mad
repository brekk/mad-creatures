import type { Maybe } from "Maybe"
import type { Random } from "Random"

import type { Gene } from "@/Genes"

import Dict from "Dictionary"
import List from "List"
import { Just, Nothing, fromMaybe } from "Maybe"
import Set from "Set"

import { splice } from "@/Genes"



export type Creature = Creature(Short, Short, List Gene, Short, String) | Ghost

derive Comparable Creature

isGhost :: Creature -> Boolean
export isGhost = where {
  Ghost =>
    true

  _ =>
    false
}

parent1 :: Creature -> Short
export parent1 = where {
  Ghost =>
    -1

  Creature(s, _, _, _, _) =>
    s
}

parent2 :: Creature -> Short
export parent2 = where {
  Ghost =>
    -1

  Creature(_, s, _, _, _) =>
    s
}

genes :: Creature -> List Gene
export genes = where {
  Ghost =>
    []

  Creature(_, _, g, _, _) =>
    g
}

name :: Creature -> String
export name = where {
  Creature(_, _, _, _, n) =>
    n

  Ghost =>
    "?"
}
id :: Creature -> Short
export id = where {
  Creature(_, _, _, i, _) =>
    i

  Ghost =>
    -1
}

parents :: Dictionary Short Creature -> Creature -> #[Maybe Creature, Maybe Creature]
export parents = (lookup, c) => {
  getter = Dict.get($, lookup)
  p1 = parent1(c)
  p2 = parent2(c)
  return #[getter(p1), getter(p2)]
}

isParent :: Creature -> Creature -> Boolean
export isParent = (p, child) => {
  rawId = id(p)
  a = parent1(child)
  b = parent2(child)
  return rawId == a || rawId == b
}

ancestors :: Dictionary Short Creature -> Creature -> Set Creature
export ancestors = (lookup, c) => {
  ax = []
  walk :: Creature -> List Creature
  walk = pipe(
    parents(lookup),
    where {
      #[Just(a), Just(b)] =>
        [a, b]

      #[Just(a), Nothing] =>
        [a]

      #[Nothing, Just(b)] =>
        [b]

      _ =>
        []
    },
    (y) => {
      ax := List.concat(ax, y)
      return map(walk, y)
    },
  )
  walk(c)
  return Set.fromList(ax)
}

isAncestor :: Dictionary Short Creature -> Creature -> Creature -> Boolean
export isAncestor = (lookup, parent, c) => pipe(
  ancestors(lookup),
  Set.toList,
  map(id),
  List.includes(id(parent)),
)(c)

original :: List Gene -> Short -> String -> Creature
export original = Creature(-1, -1)

reproduce :: Random -> String -> Short -> Creature -> Creature -> Creature
export reproduce = (r, newName, s, a, b) => {
  ag = genes(a)
  bg = genes(b)
  mixed = splice(r, ag, bg)
  return Creature(id(a), id(b), mixed, s, newName)
}

clone :: String -> Short -> Creature -> Creature
export clone = (newName, s, a) => Creature(id(a), -1, genes(a), s, newName)


structuredReproduce :: Dictionary Short Creature
  -> Boolean
  -> Random
  -> String
  -> Short
  -> Creature
  -> Creature
  -> Maybe Creature
export structuredReproduce = (lookup, noAncestors, r, newName, s, a, b) => {
  isAnc = isAncestor(lookup)
  return if (noAncestors && (isAnc(a, b) || isAnc(b, a))) {
    Nothing
  } else {
    Just(reproduce(r, newName, s, a, b))
  }
}

nameFromId :: Dictionary Short Creature -> Short -> String
export nameFromId = (creatures, s) => pipe(
  Dict.get(s),
  map(name),
  fromMaybe("?"),
)(creatures)
